<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tower Defense</title>
  <style>
    body {
      margin: 0;
      display: flex;
      font-family: sans-serif;
    }
    #game {
      background: #eee;
      width: 800px;
      height: 600px;
      display: block;
      border: 2px solid #000;
    }
    #shop {
      width: 200px;
      padding: 10px;
      background: #ccc;
      border-left: 2px solid #000;
    }
    .tower-btn {
      display: block;
      margin-bottom: 10px;
      padding: 10px;
      background: #444;
      color: #fff;
      text-align: center;
      cursor: pointer;
    }
    .locked {
      background: #888;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<div id="shop">
  <h3>Shop</h3>
  <div class="tower-btn" onclick="selectTower('basic')">Basic Tower - $100</div>
  <div class="tower-btn" onclick="selectTower('strong')">Strong Tower - $200</div>
  <div class="tower-btn locked" id="vstrong-btn" onclick="selectTower('verystrong')">Very Strong Tower - $500</div>
  <hr>
  <p><strong>Money:</strong> $<span id="money">300</span></p>
  <p><strong>Level:</strong> <span id="level">1</span></p>
  <p><strong>Health:</strong> <span id="health">100</span></p>
  <p><strong>Status:</strong> <span id="status">Running</span></p>
  <small>Press [Space] to Pause/Resume</small>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let towers = [];
let enemies = [];
let bullets = [];
let money = 300;
let health = 100;
let level = 1;
let enemyHP = 50;
let enemySpawnRate = 2000;
let selectedTower = null;
let paused = false;
let lastTime = 0;
let enemiesToSpawn = 0;
let spawning = false;


  let waypoints = [];
function generatePath() {
  waypoints = [];
  let x = 0;
  for (let i = 0; i < 6; i++) {
    x += Math.random() * 120 + 100;
    let y = Math.random() * 400 + 100;
    waypoints.push({ x: Math.min(x, 780), y });
  }
}

const towerTypes = {
  basic: { cost: 100, range: 100, damage: 10, fireRate: 1000 },
  strong: { cost: 200, range: 150, damage: 25, fireRate: 1500 },
  verystrong: { cost: 500, range: 200, damage: 50, fireRate: 2000 }
};

function selectTower(type) {
  if (type === 'verystrong' && level < 10) return; // lock until level 10
  selectedTower = type;
}

canvas.addEventListener('click', (e) => {
  if (!selectedTower) return;
  const tower = towerTypes[selectedTower];
  if (money >= tower.cost) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    towers.push({...tower, x, y, lastShot: 0});
    money -= tower.cost;
    selectedTower = null;
    updateUI();
  }
});

function drawPath() {
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(waypoints[0].x, waypoints[0].y);
  for (let wp of waypoints.slice(1)) {
    ctx.lineTo(wp.x, wp.y);
  }
  ctx.stroke();
}


function drawEnemies() {
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  for (let e of enemies) {
    // Draw enemy
    ctx.fillStyle = 'red';
    ctx.fillRect(e.x - 10, e.y - 10, 20, 20);

    // Draw numeric health above enemy
    ctx.fillStyle = 'black';
    ctx.fillText(`${e.hp}/${e.maxHp}`, e.x, e.y - 15);
  }
}


function drawTowers() {
  for (let t of towers) {
    if (t === undefined) continue;
    ctx.beginPath();
    switch(t.cost) {
      case 100: // basic
        ctx.fillStyle = 'blue';
        break;
      case 200: // strong
        ctx.fillStyle = 'green';
        break;
      case 500: // very strong
        ctx.fillStyle = 'red';
        break;
      default:
        ctx.fillStyle = 'gray';
    }
    ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}


function drawBullets() {
  ctx.fillStyle = 'black';
  for (let b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    const target = waypoints[e.targetIndex];
    if (!target) {
      enemies.splice(i, 1);
      health -= 10;
      updateUI();
      continue;
    }

    const dx = target.x - e.x;
    const dy = target.y - e.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 1) {
      e.targetIndex++;
    } else {
      const speed = 0.5 + level * 0.1;
      e.x += (dx / dist) * speed;
      e.y += (dy / dist) * speed;
    }
  }
}


function updateBullets(delta) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    if (!b.target || !enemies.includes(b.target)) {
      // Target is dead or gone, remove bullet
      bullets.splice(i, 1);
      continue;
    }
    
    // Calculate direction toward current target position
    let dx = b.target.x - b.x;
    let dy = b.target.y - b.y;
    let dist = Math.hypot(dx, dy);
    
    if (dist < 5) {
      // Hit the target
      b.target.hp -= b.damage;
      if (b.target.hp <= 0) {
        enemies.splice(enemies.indexOf(b.target), 1);
        money += 20;
        updateUI();
      }
      bullets.splice(i, 1);
      continue;
    }
    
    // Normalize direction and move bullet toward target
    b.x += (dx / dist) * b.speed * delta;
    b.y += (dy / dist) * b.speed * delta;
  }
}


function shootBullets(time) {
  for (let t of towers) {
    if (time - t.lastShot > t.fireRate) {
      let target = enemies.find(e => Math.hypot(t.x - e.x, t.y - e.y) < t.range);
      if (target) {
        bullets.push({
          x: t.x,
          y: t.y,
          speed: 0.5,
          damage: t.damage,
          target: target
        });
        t.lastShot = time;
      }
    }
  }
}


function updateUI() {
  document.getElementById('money').innerText = money;
  document.getElementById('health').innerText = health;
  document.getElementById('level').innerText = level;
  document.getElementById('status').innerText = paused ? "Paused" : "Running";

  if (level >= 10) {
    const btn = document.getElementById('vstrong-btn');
    btn.classList.remove('locked');
  }
}

function spawnEnemy() {
  enemies.push({
    x: waypoints[0].x,
    y: waypoints[0].y,
    hp: enemyHP,
    maxHp: enemyHP,
    targetIndex: 1
  });
  enemiesToSpawn--;
  if (enemiesToSpawn > 0) {
    setTimeout(spawnEnemy, enemySpawnRate - level * 100);
  } else {
    spawning = false;
  }
}


function startWave() {
  if (spawning) return;
  if (enemies.length === 0) {
    enemiesToSpawn = 5 + level * 2;
    spawning = true;
    spawnEnemy();
    level++;
    enemyHP += 10;
    updateUI();
  }
}

function gameLoop(time) {
  if (paused) {
    requestAnimationFrame(gameLoop);
    return;
  }

  let delta = time - lastTime;
  lastTime = time;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPath();
  drawEnemies();
  drawTowers();
  drawBullets();
  updateEnemies();
  updateBullets(delta);
  shootBullets(time);

  if (health <= 0) {
    alert("Game Over!");
    window.location.reload();
  }

  if (enemies.length === 0 && !spawning) {
    startWave();
  }

  requestAnimationFrame(gameLoop);
}

// Spacebar toggles pause
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    paused = !paused;
    updateUI();
  }
});

updateUI();
generatePath();  
gameLoop(0);
startWave();
</script>
</body>
</html>
